üóìÔ∏è Data: 25/10/2025

N√≥s j√° sabemos que `print()` √© uma fun√ß√£o, onde chamamos pelo nome da fun√ß√£o terminando com par√™nteses.

N√≥s podemos criar nossa pr√≥pria fun√ß√£o. Uma fun√ß√£o √© um trecho de c√≥digo que serve para **replicar** determinada a√ß√£o ao longo da execu√ß√£o, usada principalmente para n√£o ter que ficar repetindo c√≥digo.

Para criar uma fun√ß√£o, n√≥s utilizamos a palavra reservada `def` nome_da_fun√ß√£o():

```python
def imprimir():
    print("V√°rias1")
    print("V√°rias2")
    print("V√°rias3")
    print("V√°rias4")
    print("V√°rias5")

imprimir()
```

* No c√≥digo acima, criamos uma fun√ß√£o `imprimir()`, e dentro do bloco desta fun√ß√£o, passamos 5 prints.
* Na √∫ltima linha n√≥s **chamamos** a fun√ß√£o, e assim os 5 prints da fun√ß√£o `imprimir()` s√£o executados em uma √∫nica linha.
* Como j√° sabemos, o interpretador do Python l√™ de cima para baixo e da esquerda para direita.
	* Quando o interpretador l√™ a fun√ß√£o, ele guarda todo o bloco de c√≥digo dela no nome da fun√ß√£o, **e N√ÉO executa**. O bloco da fun√ß√£o s√≥ √© executado quando **chamamos** a fun√ß√£o pelo nome dela.
* Ou seja, podemos criar uma fun√ß√£o e chamar ela quantas vezes quisermos, que o bloco dela ser√° executado toda vez que a fun√ß√£o for chamada.

---

## Fun√ß√µes podem receber valores

Quando criamos uma fun√ß√£o, n√≥s podemos definir **par√¢metros** entre os par√™nteses do nome dela. Esses par√¢metros funcionam como "vari√°veis" que ir√£o receber valores no momento em que a fun√ß√£o for chamada.

Um **par√¢metro** √© o nome dado ao campo que colocamos **na defini√ß√£o da fun√ß√£o**. Ele n√£o cont√©m nenhum valor, eles apenas **ESPERAM** por um valor.

Quando chamamos a fun√ß√£o, passamos **argumentos**, e esses argumentos s√£o atribu√≠dos aos par√¢metros.

```python
def imprimir(a, b, c):
    print(a)
    print(b)
    print(c)

imprimir("Argumento1", "Argumento2", "Argumento3")
```

* No c√≥digo acima, na defini√ß√£o da fun√ß√£o imprimir, `a`, `b` e `c` s√£o **par√¢metros** que esperam um valor.
* Na √∫ltima linha, passamos tr√™s **argumentos** posicionais, que s√£o 3 strings. Depois, os **par√¢metros** `a`, `b` e `c` receberam essas 3 strings na ordem (por isso o "posicional"):
    * `a` recebeu `"Argumento1"`
    * `b` recebeu `"Argumento2"`
    * `c` recebeu `"Argumento3"`
* Por fim, executou o bloco da fun√ß√£o, realizando o print dos valores de `a`, `b` e `c`.
* Resultando em:

```
Argumento1
Argumento2
Argumento3
```

Como mencionado, podemos chamar a fun√ß√£o quantas vezes quisermos, e em cada chamada podemos passar argumentos diferentes, valores diferentes para os par√¢metros. E isso nos permite realizar coisas incr√≠veis.

Por exemplo, a cada vez que a gente chama a fun√ß√£o e passamos argumentos diferentes, temos um c√≥digo diferente e um **resultado** diferente. Ou seja, podemos mudar o resultado para qualquer outro resultado que a gente quiser, baseado no nosso algoritmo.

```python
def saudacao(nome):
    print(f"Ol√°, {nome}!")

saudacao("Juliano") # Ol√°, Juliano!
saudacao("Sofia") # Ol√°, Sofia!
```

Veja o c√≥digo acima, chamamos a mesma fun√ß√£o, onde passamos argumentos diferentes, e cada chamada teve um resultado diferente.

Um outro ponto importante √© que, se passar um par√¢metro para uma fun√ß√£o, e chamarmos a fun√ß√£o e **n√£o** passarmos **nenhum** argumento, vai gerar um erro: 
- `TypeError: saudacao() missing 1 required positional argument: 'nome'`
- Esse erro aconteceu porqu√™ a fun√ß√£o est√° esperando argumento posicional 'nome', e como n√£o teve nenhum, deu erro

Para resolver isso, basta passar um valor padr√£o para o par√¢metro:

```python
def saudacao(nome="sem nome"):
    print(f"Ol√°, {nome}!")

saudacao("Juliano") # Ol√°, Juliano!
saudacao() # Ol√°, sem nome!
```

Veja no c√≥digo acima que o par√¢metro `nome` da fun√ß√£o `saudacao` recebeu "sem nome" como valor padr√£o. Ou seja, SE na chamada da fun√ß√£o nenhum argumento for dado, o valor do par√¢metro ser√° "sem nome" ao inv√©s do argumento passado na chamada da fun√ß√£o.

Por isso na segunda chamada da fun√ß√£o ficou: "Ol√°, sem nome!"

---